#### 外观模式

##### 外观模式定义
    要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。外观模式提供一个高层次的接口，
    使得子系统易于使用。
  
##### 外观模式的使用场景
    1、为一个复杂子系统提供一个简单接口。子系统往往因为不断演化而变得越来越复杂，甚至可能被替换。
       大多数模式使用时都会产生更多、更小的类，在这使子系统更具可重用性的同时也更容易对子系统进行
       定制、修改，这种易变性使得隐藏子系统的具体实现变得尤为重要。Facade可以提供一个简单统一的
       接口，对外隐藏的子系统时，隔离变化。
    2、当你需要构建一个层次结构的子系统时，使用Facade 模式定义子系统中每层的入口点。如果子系统之间
       是相互依赖，你可以让它们仅通过Facade接口进行通信，从而简化了它们之间的依赖关系。
       
![image](https://github.com/qqhahaboy/designPattern/raw/master/facade/facadeUML.png)
       
##### 角色介绍
    Facade：系统对外的统一接口，系统内部系统地工作。
    SystemA 、SystemB、SystemC：子系统接口
    
    
##### Android 中的外观模式
![image](https://github.com/qqhahaboy/designPattern/raw/master/facade/AndroidFacadeUML.png)
    ContextImpl 内部封装了很多不同子系统的操作，例如Activity的跳转、发送广播、启动服务、设置壁纸等。
    这些工作并不是在ContextImpl中实现，而是转交给了具体的子系统进行处理。
    
    通过Context这个抽象了、定义了一组接口，ContextImpl 实现Context定义的接口，这使得用户可以通过Context
    这个接口统一进行与Anroid系统的交互，这样用户通常情况下就不需要对每个子系统进行了解。
    
##### 总结
    外观模式是一个高频使用的设计模式，它的精髓就在于封装二字。通过一个高层次结构为用户提供统一的API入口，使得
    用户通过一个类型就基本能够操作整个系统，这样减少了用户的使用成本，也能够提升系统的灵活性。
    
    有点:
        1、对客户程序隐藏子系统细节，因而减少了客户对于子系统的耦合，能够拥抱变化。
        2、外观类对子系统的接口封装，使得系统更易于使用。
    缺点：
        1、外观类接口膨胀。由于子系统的接口都有外观类统一对外暴露，使得外观类的API接口较多，在一定程度上增加了
           用户使用成本。
        2、外观类没有遵循开闭原则，当业务出现变更时，可能需要直接修改外观类。  
