### 观察者模式

##### 观察者模式的定义
    定义对象间一种对多的依赖关系，使得每当一个对象改变状态，则所有依赖它的对象都会得到通知并被自动更新。
    
#### 观察者模式的使用场景
    关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系;
     
    事件多级出发场景
     
    跨系统的消息交换场景，如消息队列、事件总线的处理机制
    
#### 观察者模式中的角色

![image](https://github.com/qqhahaboy/designPattern/raw/master/observer/observationUML.png)
 
    Subject:
        抽象主题，也就是被观察者(Obserable)的角色，抽象主题角色把所有观察者对象的引用保存在一个集合里，
        每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。
     
    ConcreteSubject:
        具体主题，该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者
        发出通知，具体主题角色又叫具体被观察者(ConcreteObserver)角色。
     
    Observer:
        抽象观察者，改角色是观察者的抽象类，它定义了一个更新接口，使得在得到主题的更改时通知更新自己。
         
    ConreteObserver:
        具体的观察者，该角色实现抽象观察者角色所定义的更新接口，以便在主题的状态发生变化时更新自身的状态。
        
#### Android源码内的观察者模式
    adapter中的notifyDataSetChanged()方法
    BroadcastReceiver机制
 
#### 观察者模式的优缺点:
    优点:
        观察者和被观察者之间是抽象耦合，应对业务变化;
        增强系统灵活性、可扩展性。
       
    缺点:
        在应用观察者模式时需要考虑开发效率和运行效率问题，程序中包括一个被观察者、多个观察者、开发和调式等内容会比较复杂，
        而且在Java中消息的通知默认是顺序执行，一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般考虑采用异步的方式。
     
